# 数组

# 88 合并两个有序数组

思路：通过三个指针p1, p2, p来进行合并，分别指向nums1的末尾，nums2的末尾以及合并后的虚末尾

p2 >= 0时，进行操作，nums[p1] > nums[p2]时把p的换成p1，p1前移，反之移动p2，最后p前移

# 27 移除元素

思路：一个指针k，在nums中遍历x，在不相等时把x保留即移动到k的位置，然后k+1，如此遍历，最后返回k

# 26 删除有序数组中的重复项

思路：k = 1，循环遍历i，从1开始，如果nums[i] ≠ nums[i - 1]则把i的值给k，然后k+1，最后返回k

# 80 删除排序数组中的重复项 II

思路：先排除数组大小小于3的因为没必要。让k从2开始，循环遍历，其余和上题思路一样

# 169 多数元素

思路：构建一个投票统计votes，遍历num，当votes为0时x的值为num，votes+1，然后if-else进行votes+1的条件，nums=x时执行反之-1，最后返回x

# 189 轮转数组

思路：双指针操作，先进行一个函数的命名reverse，使用函数进行反转。然后n等于长度k要取余n以此避免n = 11和n = 1效果一样的情况。然后分别进行反转——整体反转，前k个反转，k到n反转

# 121 买卖股票的最佳时机

思路：首先进行cost和profit的命名，cost首先要使其为正无穷保证不会崩溃。循环遍历prices，cost是最小值（cost，price）profit为最大值（profit，利润）最后返回profit

# 122 买卖股票的最佳时机 II

思路：贪心算法，遍历所有。profit为0然后对i进行遍历，从1开始，当i的比前一天的大，我们就可以计算当前的利润累加

# 55 跳跃游戏

思路：最大长度为0，循环遍历i和jump，i是当前位置jump是当前位置的值即步长。当最大长度 ≥ i并且i + jump > 最大长度时，最大长度变为i+步长

最后返回最大长度但要大于等于i

# 45 跳跃游戏 Ⅱ

思路：命名三个变量——最终边界、最远距离、步长。循环遍历整个数组，最远距离为当前最远距离和当前位置的计算后结果的最大值，当i到达边界时，更新end并时步长+1最终返回步长

# 274 H指数

先对数组进行降序排列。遍历数组，如果索引大于引用次数则返回索引，最后返回数组长度

# 380 O(1)时间插入、删除和获取随机元素

初始化：nums存数据，用数组。pos存索引用字典。

添加：当不存在则直接一个append一个指定为最后一个

删除：当存在则进行操作。idx和last分别指定val的索引和nums的最后一个，将nums索引位置换到最后，last的所有换到idx的位置，删除nums最后一个，释放索引

返回随机数：random函数，后面用choice指定寻找的主体

# 238 **除自身以外数组的乘积**

思路：初始化一个长度为len(nums)用1填充的数组，tmp为1为辅助变量。下三角为个元素相乘，也就是除去i本身的之前的元素相乘。上三角是倒序的相乘用i位置的元素去乘自己之前的元素最后下三角乘上三角。返回ans

# 134 加油站

思路：当gas总量小于cost总量直接返回-1。从0开始，总数total为0。开始循环遍历，total就是gas-cost的累加，如果当前total小于0直接start后移一位total重新为0继续找，最后返回start

# 135 分糖果

思路：两条线从左到右首先遍历一遍，从1开始到n如果右大于左则右的是左的+1。反过来右到左，左大于右则取最大值（其左边的和其右边的加1哪个大选哪个）最后将candy计算加和值

# 42 接雨水

思路：为空返回0作保障

两个左右数组分别用0填充，并将0号位和最后一个位置的值放入

循环开始从1开始，右的填入，用最大值，倒序循环开始，左的填入，用最大值

命一个变量res，循环，当前位置的值就是左右两个的最小值减去该位置的高度。

核心逻辑就是用左右数组求出整个的面积最后减去给出的面积得到结果。

# 13 罗马数字转整数

思路：核心逻辑就是解释里面的三句话，从左往右遍历如果当前小于右边就把当前的减掉其他情况加。最后加上最右边的那个，因为最右边已经无法遍历。

# 12 整数转罗马数字

思路：和十进制转二进制一样，除当前然后取余

# 58 最后一个单词的长度

思路：简单来说就是while循环从最后一个走，当j走到第一个空格时停下然后计算就得到了结果。j是n-1。但在这之前需要保证最后一个字符不是空格，如果是空格就需要n前移一位

# 14 最长公共前缀

思路：通过python自带的函数max和min来进行比较。通过比较不同字符的ascII码来得到最大的和最小的。之后迭代循环当遇到不相等的直接返回从起始到i的全部字符。如果全部通过则直接返回s1

# 151 反转字符串里的单词

直接用join(s.split()[::-1])

# 6 Z字形变换

res用占位符占位所有

i取0flag取-1。循环遍历开始，当i为0或者i是numRows-1时flag取反。跳出if i+=flag。最后返回

# 28 找出字符串中第一个匹配的下标

直接暴力匹配，即只要haystack从i到i+n有相等的就返回i，其余返回-1

# 68 文本左右对齐

思路：第一个模块是切分，也就是每一行当中究竟包含哪几个单词。第二个模块是填充，也就是每一行当中的单词怎么安排。

对于切分而言当然使用贪心法，也就是每一行尽量多放单词。用curLen和curWords记录当前已经放置的单词总长度以及单词。这里有一个坑点是由于每两个单词之间至少需要一个空格， 所以还需要考虑空格的长度。如果当前的单词w加入，那么空格的数量就是len(curWords)。所以只需要判断len(w) + curLen + len(curWords) <= maxWidth即可。

切分的逻辑搞定之后，填充也不麻烦。确定了单词的数量，也确定了单词的总长和这一行的长度，那么就可以确定空格的数量。空格的数量是maxWidth - curLen。然后用空格的数量除以空隙的数量，就可以得到每个空隙需要安排多少个空格。这样除并不一定能整除，如果不能整除，那么剩下的余数平均分配到前面的空隙当中，每个空隙多安排一个空格。